class Point {
    // stores the x, y, z coordinates
    double x, y, z;
    // stores the timeStamp of these coordinates
    // used to calculate the split
    double timeStamp;

    string Get() {
        return "x = " + x + ", y = " + y + ", z = " + z + ", time = " + timeStamp;
    }
}


// map id
string lastMap;
string currentMap;

// 2d array of ghost points
// first array is always the current player
// 2nd and 3rd array are always the player's ghost if it exists

// hard limit on the array size
uint32 arrayMaxSize = 1000000;  // 1,000,000
uint8 numCars = 3;
array<array<Point>> ghostPoints(numCars, array<Point>(0));

// optimisation setting
uint8 framesBetweenLog = 5;
uint8 currentFrameNumber = 0;

// arraySize is not in here
// create a miscellaneous array for each ghost
array<Miscellaneous> miscArray(numCars);

// stores the number of where to log the value
uint32 currentLogIndex = 0;

// variable to store the current time
// TODO: fix time desync or create a better time logging system
double currentTimeSeconds = 0;

void ResizeArrays(uint numberGhosts, uint runLength) {
    // resize the main array
    ghostPoints.Resize(numberGhosts);

    // resize each subarray
    for (uint i = 0; i < numberGhosts; i++) {
        ghostPoints[i].Resize(runLength);
    }
}

// reset only the vars relevant to the current race
void ResetRaceVars() {
    // reset the current log number to 0
    currentLogIndex = 0;

    // reset current time
    currentTimeSeconds = 0;

    // reset currentFrameNumber just so always starts at 0
}

// function to reset all variables
void ResetAllVars() {
    ResetRaceVars();

    // empty the arrays
    ResizeArrays(numCars, 0);

    // reset the misc array
    ResetMiscArray(numCars, miscArray);
}

// TODO: fix issue where misc array is not updated after setting a record for the first time

void Main() {
    // assign array size on load
    // ResizeArrays(numCars, arraySize);
}

void Update(float dt) {
    ISceneVis@ scene = GetApp().GameScene;
    // gets the track
    CGameCtnChallenge@ track = GetApp().RootMap;

    // ensures the player is in a race
    if (scene is null) {
        return;
    }

    // get all of the cars and ghosts
    // ONLY DO THIS IF SCENE IS NOT NULL

    // TODO: CREATE A SOLUTION TO INDEX CHANGING WHEN CARS FINISH
    // TODO: REPLACE INDEX WITH A DIFFERENT SOLUTION THAT USES ID INSTEAD
    // TODO: CREATE FUNCTION TO MAKE THE MISC ARRAY
    // TODO: ALSO, ADD A METHOD OF STATING WHETHER AN ARRAY IS COMPLETE SO NO LONGER NEEDS TO BE CALCULATED
    CSceneVehicleVis@[] cars = VehicleState::GetAllVis(scene);
    CSceneVehicleVisState@ thisCar = VehicleState::ViewingPlayerState();

    // ----------------------------------------------------------------------

    // ensures the track exists
    if (track is null) {
        // not the current map should be nothing
        currentMap = "";
    }
    else {
        // otherwise update the map
        lastMap = currentMap;
        currentMap = track.EdChallengeId;
    }

    // only set certain values upon switching track to reduce processing
    if (lastMap != currentMap) {
        print("Track is now track id: " + currentMap);

        ResetAllVars();
    }

    // -------------------------------------------------------------------------
    // checks to ensure we can proceed

    // if the currently viewing car is null (the player has finished)
    // return
    if (thisCar is null) {
        // print("Player has finished");
        return;
    }

    // check if the first vehicle (you) have a race start time of this specific value which shows when you are at the start
    if (cars[0].AsyncState.RaceStartTime == 4294967295) {
        // reset all vars related to the current race
        ResetRaceVars();
        
        // debug message
        // print("reset");

        // DONT NEED TO CONTINUE IF AT START
        return;
    }

    // check for greater than a hard limit
    if (currentLogIndex >= arrayMaxSize) {
        // print("Max array size hit");
        return;
    }

    // ----------------------------------------------------------------------------
    // pre-log housekeeping and checks

    // make misc array (only does this if not already set)
    MakeMiscArray(cars, numCars, miscArray);

    // increment currentTimeSeconds by deltatime to make a timer
    // must be before HOUSEKEEPING step otherwise time becomes de-synced
    currentTimeSeconds += (dt / 1000);


    // increment frame number then always set bound as frames framesBetweenLog
    currentFrameNumber = (currentFrameNumber + 1) % framesBetweenLog;

    // only log frames if frame number is 0
    // unless you are at the start
    if (currentFrameNumber != 0 && currentLogIndex != 0) {
        return;
    }

    // -------------------------------------------------------------------------
    // adding points scripts

    // used to only add cars up to this index in the arrays
    // find the smaller of the two
    int smallerNumber = (numCars < cars.Length) ? numCars : cars.Length;

    for (int car = 0; car < smallerNumber; car++) {
        // get the index of the current car in the misc array
        // this lines up with the points array (ensures that when cars finish the points of another car are not added to the array)
        int carIdx = IndexFromId(cars[car].Model.Id, numCars, miscArray); 

        // TODO: remove after testing
        print(carIdx);

        // if carIdx is not in miscArray then skip
        if (carIdx == -1) {
            continue;
        }        

        Point currentPoint;

        // get all of the car's data and put in a point
        currentPoint.y = cars[car].AsyncState.Position.y;
        currentPoint.x = cars[car].AsyncState.Position.x;
        currentPoint.z = cars[car].AsyncState.Position.z;

        // TODO: fix the current time stamp to more accurate method
        currentPoint.timeStamp = currentTimeSeconds;

        // reassign a point if there is space for it else insert at the end the new point
        if (currentLogIndex >= miscArray[carIdx].arraySize) {
            // set last point
            ghostPoints[carIdx].InsertLast(currentPoint);
            // increment array size here
            miscArray[carIdx].arraySize++;
        }
        else {
            ghostPoints[carIdx][currentLogIndex] = currentPoint;
        }

        // debug print
        // print(car + " " + currentPoint.Get());
    }

    // -------------------------------------------------------------------------
    // housekeeping

    // increment currentLogIndex
    currentLogIndex++;
}
    

void Render() {
    ISceneVis@ scene = GetApp().GameScene;

    // ensures the player is in a race
    if (scene is null) {
        return;
    }

    // creates window
    if (UI::Begin("Live Splits")) {
        UI::InputInt("a", currentLogIndex);
        UI::InputInt("size", miscArray[0].arraySize);
        UI::InputFloat("time", currentTimeSeconds);

        // UI::InputFloat3("Position", vec3(ghostPoints[0][currentLogIndex].y, ghostPoints[0][currentLogIndex].x, ghostPoints[0][currentLogIndex].z));
    }
    UI::End();
}